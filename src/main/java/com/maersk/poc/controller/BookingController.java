package com.maersk.poc.controller;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.TimeZone;

import javax.annotation.PostConstruct;
import javax.validation.Valid;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.reactive.function.client.ClientResponse;
import org.springframework.web.reactive.function.client.ExchangeFilterFunction;
import org.springframework.web.reactive.function.client.WebClient;

import com.maersk.poc.exception.ResourceNotFoundException;
import com.maersk.poc.model.Booking;
import com.maersk.poc.model.CheckAvailability;
import com.maersk.poc.repository.ReactiveBookingRepository;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/api")
public class BookingController {
	Logger log = LoggerFactory.getLogger(BookingController.class);

	WebClient webclient;
	@Autowired
	private RestTemplate restTemplate;

	@Autowired
	private ReactiveBookingRepository bookingRepository;

	@PostConstruct
	public void init() {
		webclient = WebClient.builder().baseUrl("http://localhost:9001/api/bookings")
				.defaultHeader(org.springframework.http.HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
				.filter(loggerRequest()) // get looger status code
				.filter(loggerResponset()).build();
	}

	@GetMapping("/bookings")
	public Flux<Booking> getAllBookingDetails() {
		return bookingRepository.findAll();
	}

	@PostMapping("/booking")
	public Mono<Booking> createBooking(@Valid @RequestBody Booking booking) {

		Long primaryKey = 9570000001L;
		// create primary key auto generated by one per request
		CheckAvailability avail = restTemplate.getForObject("http://localhost:9001/api/bookings/status",
				CheckAvailability.class);
		Integer spaces = avail.getAvailableSpace();

		primaryKey = primaryKey + spaces;
		// Timestamp in String ISO-8601 Date and Time format
		// Input
		Date date = new Date(System.currentTimeMillis());

		// Conversion
		SimpleDateFormat sdf;
		sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");

		sdf.setTimeZone(TimeZone.getTimeZone("UTC"));// other TimeZone :GMT+5:30,CET
		String indatimestamp = sdf.format(date);

		// Output
		// "2017-02-16T21:00:00.000+01:00"

		booking.setBookingRef(primaryKey);
		booking.setTimestamp(indatimestamp);
		return bookingRepository.save(booking);
	}

	@PutMapping("/booking/{id}")
	public Mono<ResponseEntity<Booking>> updateBooking(@PathVariable("id") Integer id, @RequestBody Booking booking) {
		return bookingRepository.findById(id).flatMap(bookingData -> {

			bookingData.setBookingRef(booking.getBookingRef());
			bookingData.setContainersize(booking.getContainersize());
			bookingData.setDestination(booking.getDestination());
			bookingData.setOrigin(booking.getOrigin());
			bookingData.setQuantity(booking.getQuantity());
			bookingData.setTimestamp(booking.getTimestamp());
			return bookingRepository.save(bookingData);
		}).map(updateBooking -> new ResponseEntity<>(updateBooking, HttpStatus.OK))
				.defaultIfEmpty(new ResponseEntity<>(HttpStatus.NOT_FOUND));
	}

	@PostMapping("/bookings/checkAvailable")
	public Mono<CheckAvailability> getAvailabilty() {

		Mono<CheckAvailability> responce= webclient
				.get()
				.uri("/status")
				.retrieve()
				.onStatus(HttpStatus::is5xxServerError, clientResponse ->handle5xxError(clientResponse))
				.bodyToMono(CheckAvailability.class);
		
		return responce;
				
		
		/*return responce
				.error(new ResourceNotFoundException("Sorry there was a problem processing your request"));*/
	}
	
	private Mono<? extends Throwable> handle5xxError(ClientResponse clientResponse){
		Mono<String> errorMessage=clientResponse.bodyToMono(String.class);
		
		return errorMessage.flatMap((message)->{
			log.error("Error response code is "+clientResponse.rawStatusCode() +"and message is :"+message);
			throw new ResourceNotFoundException(message);
		});
		
	}
	

	@DeleteMapping("/booking/delete")
	public ResponseEntity<String> deleteAllBooking() {
		try {
			bookingRepository.deleteAll().subscribe();
		} catch (Exception e) {
			return new ResponseEntity<>("Fail to delete!", HttpStatus.EXPECTATION_FAILED);
		}
		return new ResponseEntity<>("All customers have been deleted!", HttpStatus.OK);
	}

	private ExchangeFilterFunction loggerRequest() {
		return ExchangeFilterFunction.ofRequestProcessor(clrequest -> {
			log.info("REQUEST STATUS:: {} {}", clrequest.method(), clrequest.url());
			return Mono.just(clrequest);
		});
	}

	private ExchangeFilterFunction loggerResponset() {
		return ExchangeFilterFunction.ofResponseProcessor(clresponse -> {
			log.info("RESPONSE STATUS CODE:: {} {}", clresponse.statusCode());
			return Mono.just(clresponse);
		});
	}
	
	public String errorEndpoints() {
		return webclient.get().uri("http://localhost:8080/error").retrieve().onStatus(HttpStatus::is5xxServerError, clientResponse ->handle5xxError(clientResponse))
				.bodyToMono(String.class)
				.block();
		
	}

}
